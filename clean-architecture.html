<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clean Architecture in Real-World Projects: Lessons Learned - Osamah Hussein</title>

    <!--
    - favicon
  -->
    <link
      rel="shortcut icon"
      href="./assets/images/logo.ico"
      type="image/x-icon"
    />

    <!--
    - custom css link
  -->
    <link rel="stylesheet" href="./assets/css/style.css" />

    <!--
    - google font link
  -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <!--
    - #MAIN
  -->

    <main>
      <!--
      - #SIDEBAR
    -->

      <aside class="sidebar" data-sidebar>
        <div class="sidebar-info">
          <figure class="avatar-box">
            <img
              src="./assets/images/my-avatar.png"
              alt="Osamah Hussein"
              width="80"
            />
          </figure>

          <div class="info-content">
            <h1 class="name" title="Osamah Hussein">Osamah Hussein</h1>

            <p class="title">Software Engineer</p>
          </div>

          <button class="info_more-btn" data-sidebar-btn>
            <span>Show Contacts</span>

            <ion-icon name="chevron-down"></ion-icon>
          </button>
        </div>

        <div class="sidebar-info_more">
          <div class="separator"></div>

          <ul class="contacts-list">
            <li class="contact-item">
              <div class="icon-box">
                <ion-icon name="mail-outline"></ion-icon>
              </div>

              <div class="contact-info">
                <p class="contact-title">Email</p>

                <a href="mailto:Osamah0alini@gmail.com" class="contact-link"
                  >Osamah0alini@gmail.com</a
                >
              </div>
            </li>

            <li class="contact-item">
              <div class="icon-box">
                <ion-icon name="phone-portrait-outline"></ion-icon>
              </div>

              <div class="contact-info">
                <p class="contact-title">Phone</p>

                <a href="tel:+923334194029" class="contact-link"
                  >+92 (333)-419-4029</a
                >
              </div>
            </li>

            <li class="contact-item">
              <div class="icon-box">
                <ion-icon name="calendar-outline"></ion-icon>
              </div>

              <div class="contact-info">
                <p class="contact-title">Birthday</p>

                <time datetime="2000-05-22">May 22, 2000</time>
              </div>
            </li>

            <li class="contact-item">
              <div class="icon-box">
                <ion-icon name="location-outline"></ion-icon>
              </div>

              <div class="contact-info">
                <p class="contact-title">Location</p>

                <address>Lahore, Pakistan</address>
              </div>
            </li>
          </ul>

          <div class="separator"></div>

          <ul class="social-list">
            <li class="social-item">
              <a href="#" class="social-link">
                <ion-icon name="logo-facebook"></ion-icon>
              </a>
            </li>

            <li class="social-item">
              <a href="#" class="social-link">
                <ion-icon name="logo-twitter"></ion-icon>
              </a>
            </li>

            <li class="social-item">
              <a href="#" class="social-link">
                <ion-icon name="logo-instagram"></ion-icon>
              </a>
            </li>
          </ul>
        </div>
      </aside>

      <!--
      - #main-content
    -->

      <div class="main-content">
        <!--
        - #NAVBAR
      -->

        <nav class="navbar">
          <ul class="navbar-list">
            <li class="navbar-item">
              <a href="./index.html" class="navbar-link">About</a>
            </li>

            <li class="navbar-item">
              <a href="./index.html" class="navbar-link">Resume</a>
            </li>

            <li class="navbar-item">
              <a href="./index.html" class="navbar-link">Portfolio</a>
            </li>

            <li class="navbar-item">
              <a href="./index.html" class="navbar-link active">Blog</a>
            </li>

            <li class="navbar-item">
              <a href="./index.html" class="navbar-link">Contact</a>
            </li>
          </ul>
        </nav>

        <!--
        - #BLOG POST
      -->

        <article class="blog-post active" data-page="blog-post">
          <header>
            <h1 class="h1 article-title">Clean Architecture in Real-World Projects: Lessons Learned</h1>
            
            <div class="blog-meta">
              <div class="blog-meta-item">
                <ion-icon name="calendar-outline"></ion-icon>
                <span>December 15, 2024</span>
              </div>
              <div class="blog-meta-item">
                <ion-icon name="folder-outline"></ion-icon>
                <span>Software Architecture</span>
              </div>
              <div class="blog-meta-item">
                <ion-icon name="time-outline"></ion-icon>
                <span>10 min read</span>
              </div>
            </div>
          </header>

          <div class="blog-cover-image">
            <img src="./assets/images/blog/clean-architecture-cover.jpg" alt="Clean Architecture in Real-World Projects: Lessons Learned" />
          </div>

          <div class="blog-content">
            <p>Clean Architecture promises maintainable, testable, and flexible code. But how does it hold up in real-world projects? After implementing Clean Architecture in MediSense and several client projects, I've learned valuable lessons about when it shines, where it struggles, and how to adapt it for practical success.</p>

            <h2>Understanding Clean Architecture</h2>
            <p>Clean Architecture, popularized by Robert C. Martin (Uncle Bob), organizes code into concentric circles where dependencies point inward. The core principle is that business logic should be independent of external concerns like databases, frameworks, and UI.</p>

            <h3>The Four Layers</h3>
            <ul>
              <li><strong>Entities:</strong> Core business objects and rules</li>
              <li><strong>Use Cases:</strong> Application-specific business rules</li>
              <li><strong>Interface Adapters:</strong> Controllers, presenters, gateways</li>
              <li><strong>Frameworks & Drivers:</strong> External tools, databases, web frameworks</li>
            </ul>

            <blockquote>
              <p>"The architecture should scream about the use cases of the application, not about the frameworks it uses."</p>
            </blockquote>

            <h2>MediSense: A Clean Architecture Case Study</h2>
            <p>When building MediSense, I applied Clean Architecture principles to create a maintainable AI-powered healthcare platform. Here's how the layers mapped to real components:</p>

            <h3>Entities Layer</h3>
            <pre><code>
// Core business entities
class Patient {
  constructor(id, name, age, medicalHistory) {
    this.id = id;
    this.name = name;
    this.age = age;
    this.medicalHistory = medicalHistory;
  }

  addSymptom(symptom) {
    // Business rule: validate symptom before adding
    if (!symptom || !symptom.name) {
      throw new Error('Invalid symptom');
    }
    this.symptoms.push(symptom);
  }

  isEligibleForDiagnosis() {
    // Business rule: need at least 2 symptoms for diagnosis
    return this.symptoms.length >= 2;
  }
}

class Diagnosis {
  constructor(patientId, disease, confidence, recommendations) {
    this.patientId = patientId;
    this.disease = disease;
    this.confidence = confidence;
    this.recommendations = recommendations;
    this.timestamp = new Date();
  }

  isHighConfidence() {
    return this.confidence > 0.8;
  }
}
            </code></pre>

            <h3>Use Cases Layer</h3>
            <pre><code>
// Application-specific business logic
class DiagnosePatientsUseCase {
  constructor(patientRepository, mlModelService, auditLogger) {
    this.patientRepository = patientRepository;
    this.mlModelService = mlModelService;
    this.auditLogger = auditLogger;
  }

  async execute(patientId, symptoms) {
    // Validate input
    if (!patientId || !symptoms || symptoms.length === 0) {
      throw new Error('Invalid input for diagnosis');
    }

    // Get patient
    const patient = await this.patientRepository.findById(patientId);
    if (!patient) {
      throw new Error('Patient not found');
    }

    // Add symptoms to patient
    symptoms.forEach(symptom => patient.addSymptom(symptom));

    // Check business rules
    if (!patient.isEligibleForDiagnosis()) {
      throw new Error('Insufficient symptoms for diagnosis');
    }

    // Perform ML prediction
    const prediction = await this.mlModelService.predict(patient.symptoms);

    // Create diagnosis
    const diagnosis = new Diagnosis(
      patientId,
      prediction.disease,
      prediction.confidence,
      prediction.recommendations
    );

    // Audit logging
    await this.auditLogger.log('diagnosis_created', {
      patientId,
      disease: diagnosis.disease,
      confidence: diagnosis.confidence
    });

    return diagnosis;
  }
}
            </code></pre>

            <h3>Interface Adapters Layer</h3>
            <pre><code>
// Controllers handle HTTP requests
class DiagnosisController {
  constructor(diagnosePatientsUseCase) {
    this.diagnosePatientsUseCase = diagnosePatientsUseCase;
  }

  async diagnose(req, res) {
    try {
      const { patientId, symptoms } = req.body;
      
      const diagnosis = await this.diagnosePatientsUseCase.execute(
        patientId, 
        symptoms
      );

      res.json({
        success: true,
        data: {
          disease: diagnosis.disease,
          confidence: diagnosis.confidence,
          recommendations: diagnosis.recommendations,
          timestamp: diagnosis.timestamp
        }
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: error.message
      });
    }
  }
}

// Repository implementations
class MongoPatientRepository {
  constructor(mongoClient) {
    this.db = mongoClient.db('medisense');
    this.collection = this.db.collection('patients');
  }

  async findById(id) {
    const doc = await this.collection.findOne({ _id: id });
    if (!doc) return null;

    return new Patient(doc._id, doc.name, doc.age, doc.medicalHistory);
  }

  async save(patient) {
    await this.collection.updateOne(
      { _id: patient.id },
      { $set: patient },
      { upsert: true }
    );
  }
}
            </code></pre>

            <h2>Real-World Benefits</h2>

            <h3>1. Testability</h3>
            <p>Clean Architecture made testing MediSense straightforward. Business logic could be tested independently of external dependencies:</p>

            <pre><code>
// Testing use cases without external dependencies
describe('DiagnosePatientsUseCase', () => {
  let useCase;
  let mockPatientRepo;
  let mockMLService;
  let mockAuditLogger;

  beforeEach(() => {
    mockPatientRepo = {
      findById: jest.fn(),
      save: jest.fn()
    };
    mockMLService = {
      predict: jest.fn()
    };
    mockAuditLogger = {
      log: jest.fn()
    };

    useCase = new DiagnosePatientsUseCase(
      mockPatientRepo,
      mockMLService,
      mockAuditLogger
    );
  });

  test('should diagnose patient with valid symptoms', async () => {
    // Arrange
    const patient = new Patient('123', 'John Doe', 30, []);
    mockPatientRepo.findById.mockResolvedValue(patient);
    mockMLService.predict.mockResolvedValue({
      disease: 'Common Cold',
      confidence: 0.85,
      recommendations: ['Rest', 'Hydration']
    });

    // Act
    const diagnosis = await useCase.execute('123', [
      { name: 'fever' },
      { name: 'cough' }
    ]);

    // Assert
    expect(diagnosis.disease).toBe('Common Cold');
    expect(diagnosis.confidence).toBe(0.85);
    expect(mockAuditLogger.log).toHaveBeenCalled();
  });
});
            </code></pre>

            <h3>2. Flexibility</h3>
            <p>When requirements changed, Clean Architecture made adaptations easier. For example, switching from MongoDB to PostgreSQL only required changing the repository implementation:</p>

            <pre><code>
// New PostgreSQL implementation
class PostgresPatientRepository {
  constructor(pgClient) {
    this.client = pgClient;
  }

  async findById(id) {
    const result = await this.client.query(
      'SELECT * FROM patients WHERE id = $1',
      [id]
    );
    
    if (result.rows.length === 0) return null;

    const row = result.rows[0];
    return new Patient(row.id, row.name, row.age, row.medical_history);
  }

  async save(patient) {
    await this.client.query(
      `INSERT INTO patients (id, name, age, medical_history) 
       VALUES ($1, $2, $3, $4) 
       ON CONFLICT (id) DO UPDATE SET 
       name = $2, age = $3, medical_history = $4`,
      [patient.id, patient.name, patient.age, patient.medicalHistory]
    );
  }
}
            </code></pre>

            <h3>3. Maintainability</h3>
            <p>Clear separation of concerns made the codebase easier to understand and modify. New developers could quickly grasp the system structure and locate relevant code.</p>

            <h2>Real-World Challenges</h2>

            <h3>1. Over-Engineering for Simple Projects</h3>
            <p>Not every project needs Clean Architecture. For a simple CRUD API with basic business logic, the overhead might not be justified.</p>

            <h4>When to Use Clean Architecture:</h4>
            <ul>
              <li>Complex business logic</li>
              <li>Multiple external integrations</li>
              <li>Long-term maintenance requirements</li>
              <li>Team collaboration needs</li>
              <li>Frequent requirement changes</li>
            </ul>

            <h4>When to Consider Simpler Approaches:</h4>
            <ul>
              <li>Simple CRUD operations</li>
              <li>Prototype or proof-of-concept projects</li>
              <li>Small team with tight deadlines</li>
              <li>Well-defined, stable requirements</li>
            </ul>

            <h3>2. Learning Curve</h3>
            <p>Clean Architecture requires a mindset shift. Team members need time to understand dependency inversion and the layered approach.</p>

            <h4>Strategies for Team Adoption:</h4>
            <ul>
              <li>Start with training sessions on Clean Architecture principles</li>
              <li>Create templates and examples for common patterns</li>
              <li>Implement gradually, one module at a time</li>
              <li>Establish code review practices focused on architecture</li>
            </ul>

            <h3>3. Performance Considerations</h3>
            <p>The abstraction layers can introduce performance overhead. In MediSense, I had to optimize critical paths:</p>

            <pre><code>
// Performance optimization: caching in repository layer
class CachedPatientRepository {
  constructor(baseRepository, cache) {
    this.baseRepository = baseRepository;
    this.cache = cache;
  }

  async findById(id) {
    const cacheKey = `patient:${id}`;
    let patient = await this.cache.get(cacheKey);

    if (!patient) {
      patient = await this.baseRepository.findById(id);
      if (patient) {
        await this.cache.set(cacheKey, patient, 300); // 5 min TTL
      }
    }

    return patient;
  }
}
            </code></pre>

            <h2>Practical Implementation Guidelines</h2>

            <h3>Start with the Core</h3>
            <p>Begin by identifying and implementing your core business entities and use cases. These should be framework-agnostic and contain your essential business logic.</p>

            <h3>Use Dependency Injection</h3>
            <p>Implement a dependency injection container to manage dependencies between layers:</p>

            <pre><code>
// Simple DI container example
class DIContainer {
  constructor() {
    this.services = new Map();
  }

  register(name, factory) {
    this.services.set(name, factory);
  }

  resolve(name) {
    const factory = this.services.get(name);
    if (!factory) {
      throw new Error(`Service ${name} not found`);
    }
    return factory();
  }
}

// Registration
container.register('patientRepository', () => 
  new MongoPatientRepository(mongoClient)
);

container.register('mlModelService', () => 
  new TensorFlowMLService()
);

container.register('diagnosePatientsUseCase', () => 
  new DiagnosePatientsUseCase(
    container.resolve('patientRepository'),
    container.resolve('mlModelService'),
    container.resolve('auditLogger')
  )
);
            </code></pre>

            <h3>Define Clear Interfaces</h3>
            <p>Use interfaces or abstract classes to define contracts between layers:</p>

            <pre><code>
// Interface definitions
interface PatientRepository {
  findById(id: string): Promise<Patient | null>;
  save(patient: Patient): Promise<void>;
  findBySymptoms(symptoms: string[]): Promise<Patient[]>;
}

interface MLModelService {
  predict(symptoms: Symptom[]): Promise<Prediction>;
  retrain(data: TrainingData): Promise<void>;
}

interface AuditLogger {
  log(event: string, data: object): Promise<void>;
}
            </code></pre>

            <h2>Lessons Learned</h2>

            <h3>1. Pragmatic Application</h3>
            <p>Don't follow Clean Architecture dogmatically. Adapt it to your project's needs. Sometimes a direct database call in a controller is acceptable for simple operations.</p>

            <h3>2. Gradual Implementation</h3>
            <p>You don't need to implement Clean Architecture perfectly from day one. Start with the most critical parts and refactor gradually.</p>

            <h3>3. Team Alignment</h3>
            <p>Ensure the entire team understands and buys into the architectural approach. Inconsistent application can lead to a messy codebase.</p>

            <h3>4. Documentation is Crucial</h3>
            <p>Document your architectural decisions, especially the reasoning behind layer boundaries and dependency flows.</p>

            <h3>5. Tooling Matters</h3>
            <p>Invest in tools that support your architecture:</p>
            <ul>
              <li>Dependency injection frameworks</li>
              <li>Testing frameworks that support mocking</li>
              <li>Code analysis tools for architecture validation</li>
              <li>Documentation generators</li>
            </ul>

            <h2>When Clean Architecture Shines</h2>

            <h3>Complex Business Logic</h3>
            <p>MediSense had complex diagnostic algorithms, regulatory compliance requirements, and multiple integration points. Clean Architecture provided the structure needed to manage this complexity.</p>

            <h3>Evolving Requirements</h3>
            <p>Healthcare regulations change frequently. Clean Architecture made it easier to adapt to new compliance requirements without major rewrites.</p>

            <h3>Multiple Interfaces</h3>
            <p>MediSense needed to support web APIs, mobile apps, and integration with hospital systems. The clean separation made it easy to add new interfaces.</p>

            <h2>Conclusion</h2>
            <p>Clean Architecture is a powerful tool, but it's not a silver bullet. It excels in complex, long-lived projects with evolving requirements. However, it can be overkill for simple applications.</p>

            <p>The key is to understand the principles behind Clean Architecture and apply them judiciously. Focus on separation of concerns, dependency inversion, and testability, but don't sacrifice pragmatism for architectural purity.</p>

            <p>In MediSense, Clean Architecture enabled us to build a maintainable, testable system that could adapt to changing healthcare requirements. The initial investment in architectural setup paid dividends in reduced maintenance costs and faster feature development.</p>

            <p>Remember: architecture should serve your project's goals, not the other way around. Use Clean Architecture when it adds value, and don't be afraid to adapt it to your specific needs.</p>
          </div>

          <div class="blog-tags">
            <h4 class="h4">Tags</h4>
            <div class="tag-list">
              <span class="blog-tag">Clean Architecture</span>
              <span class="blog-tag">Software Design</span>
              <span class="blog-tag">Best Practices</span>
              <span class="blog-tag">Maintainability</span>
              <span class="blog-tag">Testing</span>
              <span class="blog-tag">Dependency Injection</span>
            </div>
          </div>

          <div class="blog-navigation">
            <a href="./index.html" class="btn-back">
              <ion-icon name="arrow-back-outline"></ion-icon>
              <span>Back</span>
            </a>
          </div>
        </article>
      </div>
    </main>

    <!--
    - custom js link
  -->
    <script src="./assets/js/script.js"></script>

    <!--
    - ionicon link
  -->
    <script
      type="module"
      src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"
    ></script>
    <script
      nomodule
      src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"
    ></script>
  </body>
</html>

